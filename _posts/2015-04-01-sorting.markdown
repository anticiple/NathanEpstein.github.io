---
layout: post
author: Nathan Epstein
title:  "Sorting Algorithms Guide"
date:   2015-04-01 12:00:00
categories: jekyll update
img: "../img/sort.png"
---

##Introduction

Whether for interviewing or general CS knowledge, it is frequently helpful for programmers to be familiar with sorting algorithms. To that end, this post contains implementations of several common sorting algorithms in both Ruby and JavaScript. Implementations are written so as to be clear and readable.

##Bubble Sort

####Worst Case Performance:
<span class='n2'></span>

####Description:
Repeatedly pass through the array comparing adjacent pairs of elements. If the pair is in the wrong order, swap them. If you get through the whole array without swapping a pair, it is sorted.

####Additional Notes:
Simple to implement but generally a bad choice because of the slow run time.

<div class="btn-group" role="group">
  <button id='rbubble' type="button" class="btn btn-default">Ruby</button>
  <button id='jbubble' type="button" class="btn btn-default">JavaScript</button>
</div>
<div id='rubyBubble'>
{% highlight ruby %}
def bubble_sort(array)
  while true
    swapless_sweep = true
    for i in 0..(array.length-2)
      if array[i] > array[i+1]
        swap = array[i]
        array[i] = array[i+1]
        array[i+1] = swap
        swapless_sweep = false
      end
    end
    return array if swapless_sweep
  end
end
{% endhighlight %}
</div>
<div hidden id='jsBubble'>
{% highlight javascript %}
function bubbleSort(arr){
  while (true){
    swapless = true;
    for (var i=0; i < arr.length-1; i++){
      if (arr[i] > arr[i+1]){
        var swap = arr[i];
        arr[i] = arr[i+1];
        arr[i+1] = swap;
        swapless = false
      }
    }
    if (swapless) return arr;
  }
}
{% endhighlight %}
</div>

<!-- end bubble, start insertion -->

##Insertion Sort

####Worst Case Performance:
<span class='n2'></span>

####Description:
Insertion sort repeatedly iterates over the array to build a sorted output list. Every iteration, we take a new element, find the location it belongs within the sorted list, and insert it there. We repeat until all elements have been inserted.

####Additional Notes:
Simple to implement and efficient for small arrays but again problematic because of the worst case run time.

<div class="btn-group" role="group">
  <button id='rInsert' type="button" class="btn btn-default">Ruby</button>
  <button id='jInsert' type="button" class="btn btn-default">JavaScript</button>
</div>
<div id='rubyInsert'>
{% highlight ruby %}
def insertion_sort(array)
  for i in 1..array.length-1
    j = i
    while j > 0 && array[j-1] > array[j]
      pivot = array[j]
      array[j] = array[j-1]
      array[j-1] = pivot
      j -= 1
    end
  end
  return array
end
{% endhighlight %}
</div>
<div hidden id='jsInsert'>
{% highlight javascript %}
function insertSort(arr){
  for (var i=1;i<arr.length;i++){
    var j = i;
    while ((j > 0) && (arr[j-1] > arr[j])){
      var pivot = arr[j];
      arr[j] = arr[j-1];
      arr[j-1] = pivot;
      j -= 1;
    }
  }
  return arr;
}
{% endhighlight %}
</div>
<!-- end insertion, start merge -->

##Merge Sort

####Worst Case Performance:
<span class='nlogn'></span>

####Description:
Merge sort breaks the array into its individual elements (arrays of length one) and repeatedly merges smaller sorted arrays (using the merge function) into a larger sorted array. We merge pairs of sorted sub-arrays until we have the completely sorted array.

####Additional Notes:
Generally a good choice if we don't know anything about the array we are going to sort. Very commonly asked about.

<div class="btn-group" role="group">
  <button id='rMerge' type="button" class="btn btn-default">Ruby</button>
  <button id='jMerge' type="button" class="btn btn-default">JavaScript</button>
</div>
<div id='rubyMerge'>
{% highlight ruby %}
def merge(left, right)
  merged = []
  until left.length == 0 && right.length == 0
    left_empty = left.length == 0
    right_empty = right.length == 0
    both = !left_empty && !right_empty
    if (left_empty && !right_empty || both && left[0] > right[0])
      merged.push(right.shift())
    else
      merged.push(left.shift())
    end
  end
  return merged
end

def merge_sort(array)
  if array.length <= 1
    return array
  else
    half = (array.length/2).floor
    left = array.slice(0,half)
    right = array.slice(half,array.length)
    return merge(sort(left),sort(right))
  end
end
{% endhighlight %}
</div>
<div hidden id='jsMerge'>
{% highlight javascript %}
function merge (left,right){
  var merged = [];
  if (left && right){
    while (left.length && right.length){
      if (left[0] < right[0]){
        merged.push(left.shift());
      }
      else{
        merged.push(right.shift());
      }
    }
    while (left.length) merged.push(left.shift());
    while (right.length) merged.push(right.shift());
  }
  else{
    merged = left;
  }
  return merged;
}

function mergeSort(arr){
  if (arr.length <= 1) return arr;

  var mid = Math.floor(arr.length/2);
  var left = arr.slice(0,mid);
  var right = arr.slice(mid,arr.length);

  return merge(mergeSort(left),mergeSort(right));
}
{% endhighlight %}
</div>
<!-- end merge, begin quick -->

##Quick Sort

####Worst Case Performance:
<span class='n2'></span>

####Description:
Quick sort chooses a pivot element and breaks the array into those elements larger and smaller than the pivot. We recursively call quicksort on each of those groups and return the joined arrays - sorted(smaller) + pivot + sorted(bigger). Base case is an array of length 0 or 1 (which we immediately return).

####Additional Notes:
Slower worst case performance than merge sort but this is rare in practice. Faster than merge sort in many cases.

<div class="btn-group" role="group">
  <button id='rQuick' type="button" class="btn btn-default">Ruby</button>
  <button id='jQuick' type="button" class="btn btn-default">JavaScript</button>
</div>
<div id='rubyQuick'>
{% highlight ruby %}
def quick_sort(array)
  return array if array.length < 2
  pivot = (array.length/2).floor
  left = []
  mid = []
  right = []
  for element in array
    if element < array[pivot]
      left.push(element)
    elsif element > array[pivot]
      right.push(element)
    else
      mid.push(element)
    end
  end
  return quick_sort(left).concat(mid).concat(quick_sort(right))
end
{% endhighlight %}
</div>
<div hidden id='jsQuick'>
{% highlight javascript %}
function quickSort(arr){
  if (arr.length <= 1) return arr;

  var pivot = Math.floor(arr.length/2);
  var left = [];
  var mid = [];
  var right = [];
  arr.forEach(function(elem,i){
    if (elem < arr[pivot]){
      left.push(elem);
    }
    else if (elem > arr[pivot]){
      right.push(elem);
    }
    else{
      mid.push(elem);
    }
  });

  return quickSort(left).concat(mid).concat(quickSort(right));
}
{% endhighlight %}
</div>



<!-- Katex for runtime -->
<script type="text/javascript">
  var n2 = $.parseHTML(katex.renderToString('O(n^2)'));
  $('.n2').append(n2);
   var nlogn = $.parseHTML(katex.renderToString('O(n \\cdot log(n))'));
  $('.nlogn').append(nlogn);

</script>

<!-- JS for buttons -->
<script type="text/javascript">
$('#rbubble').click(function(){
  $('#rubyBubble').show();
  $('#jsBubble').hide();
});
$('#jbubble').click(function(){
  $('#rubyBubble').hide();
  $('#jsBubble').show();
});
$('#rInsert').click(function(){
  $('#rubyInsert').show();
  $('#jsInsert').hide();
});
$('#jInsert').click(function(){
  $('#rubyInsert').hide();
  $('#jsInsert').show();
});
$('#rMerge').click(function(){
  $('#rubyMerge').show();
  $('#jsMerge').hide();
});
$('#jMerge').click(function(){
  $('#rubyMerge').hide();
  $('#jsMerge').show();
});
$('#rQuick').click(function(){
  $('#rubyQuick').show();
  $('#jsQuick').hide();
});
$('#jQuick').click(function(){
  $('#rubyQuick').hide();
  $('#jsQuick').show();
});
</script>
